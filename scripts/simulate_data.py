
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/Simulation Module.ipynb
import math
import numpy as np
from functools import partial
import torch.nn.functional as F
import torch

import path
with path.Path(".."):
    from scripts.data_augmentation import resize_batch_cpu

def listify(p): return list(p) if hasattr(p, "__iter__") else [p]

#pulse_functions
def cos_sin_pulse(fraction,**kwargs):
    return math.sin(fraction*(2*math.pi))+math.cos(fraction*(4*math.pi)+5/4)

#post_processing functions
def random_noise(img, intensity=5, **kwargs): return img + np.random.randn(*img.shape)*intensity
def scaled_noise(img, intensity=0.05, **kwargs): return img*(np.random.randn(*img.shape)*intensity + 1)

def simulate_pulsatility(img, gt, pulse_func, post_proc = None, n_slices = 100, randomize = True,
                         scale=1, bias=0, **kwargs):
    times = sorted(np.random.random(n_slices)) if randomize else np.linspace(0,1,n_slices)
    out = np.stack([img+gt*pulse_func(t, **kwargs)*scale+bias for t in times])
    if post_proc is not None:
        for f in listify(post_proc): out = f(out, **kwargs)
    return out

def generate_pulsemap_gt(src_img, size, div = 10, pulse_thresh = None, src_thresh = None):
    n,ch,h,w = src_img.shape
    pulse_base = np.random.random([n,ch,h//div, w//div])
    if pulse_thresh is not None: pulse_base = np.clip(pulse_base-pulse_thresh, 0, 1)*2
    pulse_map = resize_batch_cpu(torch.tensor(pulse_base), size)
    if src_thresh is not None: pulse_map = pulse_map*(src_img>src_thresh)
    return pulse_map

def simulate_pulsatility_images(src_image, size=200, pulse_thresh=0.8, src_thresh=20, noise_intensity=0.05, pulse_scale=100):
    """ Returns a simulated image array and a ground truth pulsatility map based on an initial volume
    size - size the input will be resized to
    pulse_thresh - Value from 0-1.  Higher means there will be smaller and sharper pulse widths
    src_thresh - Intensities below the src_thresh will be used to mask the pulsatility map
    noise_intensity = Intensity of the noise
    pulse_scale - How much to scale the pulsatility maps when introducing them into the source images
    """
    brain = np.transpose(src_image, (2,1,0))[:,None,:,:]
    brain_map = resize_batch_cpu(torch.tensor(brain), size)
    pulse_map = generate_pulsemap_gt(brain_map, size, pulse_thresh =pulse_thresh, src_thresh=src_thresh)
    pulse_func = cos_sin_pulse
    post_proc = [partial(scaled_noise, intensity = noise_intensity)]
    simulated_image_array = simulate_pulsatility(brain_map, pulse_map, pulse_func,post_proc=post_proc, scale=pulse_scale)
    return simulated_image_array, pulse_map

def get_folder(base_path, root = "First_Images_"):
    for counter in range(999):
        folder_name=f"{root}{counter:03}"
        if not (base_path/folder_name).exists(): return folder_name

def output_slices(root_path, raw_stack, ground_truth_stack):
    img_stack = raw_stack/raw_stack.mean(axis=(2,3), keepdims=True)
    img_stack = np.transpose(img_stack, axes=(0,2,3,1))

    images_path = root_path/'Images'; images_path.mkdir(exist_ok=True)
    gts_path = root_path/'Ground Truths'; gts_path.mkdir(exist_ok=True)

    n, w, h, c = img_stack.shape

    output_folder_name = get_folder(images_path)
    images_save_path=images_path/output_folder_name; images_save_path.mkdir(exist_ok=True,parents=True)
    gts_save_path=gts_path/output_folder_name; gts_save_path.mkdir(exist_ok=True,parents=True)

    for slice_num in range(n):
        imageio.imsave(images_save_path/f'{slice_num}.tif', img_stack[slice_num,...])
        imageio.imsave(gts_save_path/f'{slice_num}.tif', ground_truth_stack[slice_num,0,...])
    return True

def create_simulated_outputs(root_path, src_volume):
    root_path.mkdir(exist_ok=True, parents=True)

    #can randomize the inputs to this function to add variability
    simulated_image_array, pulse_map = simulate_pulsatility_images(src_volume)

    #all the potential channels of interest (can use them as inputs later)
    std_array = simulated_image_array.std(axis=0)
    avg_array = simulated_image_array.mean(axis=0)
    max_array = simulated_image_array.max(axis=0)
    min_array = simulated_image_array.min(axis=0)

    low_array = np.percentile(simulated_image_array, 25, axis=0)
    high_array = np.percentile(simulated_image_array, 75, axis=0)
    iqr_array = high_array-low_array


    raw_stack = np.concatenate([avg_array, std_array, iqr_array], axis = 1)
    output_slices(root_path, raw_stack, pulse_map)